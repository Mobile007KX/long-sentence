<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AIæç¤ºè¯ä¼˜åŒ–å™¨</title>
    <style>
        body {
            font-family: monospace;
            padding: 20px;
            background: #1e1e1e;
            color: #d4d4d4;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        .status {
            padding: 10px;
            background: #2d2d30;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        .test-case {
            margin: 10px 0;
            padding: 10px;
            background: #252526;
            border-radius: 4px;
        }
        .success { color: #4ec9b0; }
        .error { color: #f48771; }
        .warning { color: #dcdcaa; }
        .progress {
            width: 100%;
            height: 20px;
            background: #3c3c3c;
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
        }
        .progress-bar {
            height: 100%;
            background: #007acc;
            transition: width 0.3s;
        }
        button {
            background: #007acc;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #005a9e;
        }
        .results {
            white-space: pre-wrap;
            font-size: 12px;
            background: #1e1e1e;
            padding: 15px;
            border-radius: 4px;
            max-height: 600px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¤– AIæç¤ºè¯è‡ªåŠ¨ä¼˜åŒ–ç³»ç»Ÿ</h1>
        
        <div class="status" id="status">
            å‡†å¤‡å°±ç»ª...
        </div>
        
        <div class="progress">
            <div class="progress-bar" id="progressBar" style="width: 0%"></div>
        </div>
        
        <div>
            <button onclick="startOptimization()">å¼€å§‹ä¼˜åŒ–</button>
            <button onclick="stopOptimization()">åœæ­¢</button>
            <button onclick="clearResults()">æ¸…é™¤ç»“æœ</button>
        </div>
        
        <div class="results" id="results"></div>
    </div>

    <script>
        let isRunning = false;
        let currentIteration = 0;
        let successRate = 0;
        let bestPrompt = null;
        let bestScore = 0;

        // æµ‹è¯•ç”¨ä¾‹é›†
        const testCases = [
            {
                sentence: "The students who studied hard finally passed the difficult exam yesterday.",
                pattern: "SVO",
                expected: {
                    subject: [0, 4], // The students who studied hard
                    verb: [6, 6],    // passed
                    object: [7, 9],  // the difficult exam
                    modifiers: [[5, 5], [10, 10]] // finally, yesterday
                }
            },
            {
                sentence: "The book that I bought yesterday is very interesting.",
                pattern: "SVP",
                expected: {
                    subject: [0, 5], // The book that I bought yesterday
                    verb: [6, 6],    // is
                    complement: [7, 8] // very interesting
                }
            },
            {
                sentence: "The teacher gave the students who worked overtime extra homework.",
                pattern: "SVOO",
                expected: {
                    subject: [0, 1], // The teacher
                    verb: [2, 2],    // gave
                    indirectObject: [3, 7], // the students who worked overtime
                    object: [8, 9]   // extra homework
                }
            },
            {
                sentence: "They elected him president unanimously.",
                pattern: "SVOC",
                expected: {
                    subject: [0, 0], // They
                    verb: [1, 1],    // elected
                    object: [2, 2],  // him
                    complement: [3, 3], // president
                    modifiers: [[4, 4]] // unanimously
                }
            },
            {
                sentence: "The proposal which the committee reviewed carefully needs more work.",
                pattern: "SVO",
                expected: {
                    subject: [0, 6], // The proposal which the committee reviewed carefully
                    verb: [7, 7],    // needs
                    object: [8, 9]   // more work
                }
            }
        ];

        // åŠ¨æ€æç¤ºè¯æ¨¡æ¿
        class PromptOptimizer {
            constructor() {
                this.variations = {
                    rules: [
                        "å®šè¯­ä»å¥å¿…é¡»åŒ…å«åœ¨å®ƒæ‰€ä¿®é¥°çš„åè¯æ‰€å±çš„æˆåˆ†ä¸­",
                        "å…³ç³»ä»£è¯åçš„æ‰€æœ‰å†…å®¹ç›´åˆ°é€—å·æˆ–ä¸‹ä¸€ä¸ªä¸»è¦æˆåˆ†éƒ½å±äºå®šè¯­ä»å¥",
                        "å®šè¯­ä»å¥çš„è¾¹ç•Œç”±å…³ç³»ä»£è¯å¼€å§‹ï¼Œåˆ°ä»å¥è°“è¯­çš„å®¾è¯­æˆ–è¡¥è¯­ç»“æŸ"
                    ],
                    examples: [
                        {
                            sentence: "The students who studied hard passed.",
                            marking: "ä¸»è¯­:[0-4] åŒ…å«å®šè¯­ä»å¥"
                        },
                        {
                            sentence: "The book that I read is good.",
                            marking: "ä¸»è¯­:[0-4] åŒ…å«å®šè¯­ä»å¥that I read"
                        }
                    ],
                    emphasis: [
                        "ä¸¥æ ¼éµå®ˆ",
                        "å¿…é¡»ç²¾ç¡®",
                        "ç‰¹åˆ«æ³¨æ„"
                    ]
                };
                this.currentConfig = {
                    ruleIndex: 0,
                    exampleCount: 1,
                    emphasisLevel: 0
                };
            }

            generatePrompt() {
                const rule = this.variations.rules[this.currentConfig.ruleIndex];
                const examples = this.variations.examples.slice(0, this.currentConfig.exampleCount + 1);
                const emphasis = this.variations.emphasis[this.currentConfig.emphasisLevel];
                
                return `ä½ æ˜¯è‹±è¯­å¥å­ç»“æ„åˆ†æä¸“å®¶ã€‚${emphasis}ä»¥ä¸‹è§„åˆ™ï¼š

æ ¸å¿ƒè§„åˆ™ï¼š
1. ${rule}
2. çŠ¶è¯­(finally, yesterdayç­‰)ä¸å±äºä¸»è°“å®¾ï¼Œå•ç‹¬æ ‡è®°
3. ä½¿ç”¨ç²¾ç¡®çš„ç´¢å¼•èŒƒå›´[start, end]ï¼Œä»0å¼€å§‹

ç¤ºä¾‹ï¼š
${examples.map(ex => `"${ex.sentence}" â†’ ${ex.marking}`).join('\n')}

åˆ†æå¥å­æ—¶è¿”å›JSONï¼š
{
    "tokens": ["åˆ†è¯æ•°ç»„"],
    "components": {
        "subject": {"range": [å¼€å§‹, ç»“æŸ], "text": "æ–‡æœ¬"},
        "verb": {"range": [å¼€å§‹, ç»“æŸ], "text": "æ–‡æœ¬"},
        "object": {"range": [å¼€å§‹, ç»“æŸ], "text": "æ–‡æœ¬"}
    },
    "modifiers": [{"range": [å¼€å§‹, ç»“æŸ], "type": "ç±»å‹"}]
}`;
            }

            evolve(score) {
                // æ ¹æ®å¾—åˆ†è¿›åŒ–æç¤ºè¯é…ç½®
                if (score < 0.5) {
                    this.currentConfig.ruleIndex = (this.currentConfig.ruleIndex + 1) % this.variations.rules.length;
                } else if (score < 0.8) {
                    this.currentConfig.exampleCount = Math.min(this.currentConfig.exampleCount + 1, this.variations.examples.length - 1);
                } else if (score < 0.95) {
                    this.currentConfig.emphasisLevel = Math.min(this.currentConfig.emphasisLevel + 1, this.variations.emphasis.length - 1);
                }
            }
        }

        const optimizer = new PromptOptimizer();

        async function testPrompt(promptText) {
            const results = [];
            let correctCount = 0;
            
            for (const testCase of testCases) {
                try {
                    const response = await callQwenAPI(promptText, testCase.sentence, testCase.pattern);
                    const score = evaluateResponse(response, testCase.expected);
                    
                    results.push({
                        sentence: testCase.sentence,
                        success: score > 0.9,
                        score: score,
                        response: response
                    });
                    
                    if (score > 0.9) correctCount++;
                } catch (error) {
                    results.push({
                        sentence: testCase.sentence,
                        success: false,
                        score: 0,
                        error: error.message
                    });
                }
            }
            
            return {
                successRate: correctCount / testCases.length,
                results: results
            };
        }

        async function callQwenAPI(systemPrompt, sentence, pattern) {
            const response = await fetch('https://dashscope-intl.aliyuncs.com/compatible-mode/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': 'Bearer sk-8a9d17f2199449ca87988c5d82ae30be'
                },
                body: JSON.stringify({
                    model: 'qwen-turbo-latest',
                    messages: [
                        { role: "system", content: systemPrompt },
                        { role: "user", content: `åˆ†æå¥å­ï¼š"${sentence}" (å¥å‹ï¼š${pattern})` }
                    ],
                    temperature: 0.1,
                    max_tokens: 1000
                })
            });
            
            const data = await response.json();
            if (data.choices && data.choices[0]) {
                return JSON.parse(data.choices[0].message.content);
            }
            throw new Error('APIè°ƒç”¨å¤±è´¥');
        }

        function evaluateResponse(response, expected) {
            let score = 0;
            let totalChecks = 0;
            
            // æ£€æŸ¥ä¸»è¯­
            if (response.components?.subject?.range) {
                totalChecks++;
                if (arraysEqual(response.components.subject.range, expected.subject)) {
                    score++;
                }
            }
            
            // æ£€æŸ¥è°“è¯­
            if (response.components?.verb?.range) {
                totalChecks++;
                if (arraysEqual(response.components.verb.range, expected.verb)) {
                    score++;
                }
            }
            
            // æ£€æŸ¥å®¾è¯­
            if (expected.object && response.components?.object?.range) {
                totalChecks++;
                if (arraysEqual(response.components.object.range, expected.object)) {
                    score++;
                }
            }
            
            // æ£€æŸ¥ä¿®é¥°è¯­
            if (expected.modifiers && response.modifiers) {
                totalChecks++;
                let modifierScore = 0;
                for (const expectedMod of expected.modifiers) {
                    if (response.modifiers.some(mod => arraysEqual(mod.range, expectedMod))) {
                        modifierScore += 1 / expected.modifiers.length;
                    }
                }
                score += modifierScore;
            }
            
            return totalChecks > 0 ? score / totalChecks : 0;
        }

        function arraysEqual(a, b) {
            return Array.isArray(a) && Array.isArray(b) && 
                   a.length === b.length && 
                   a.every((val, index) => val === b[index]);
        }

        async function startOptimization() {
            if (isRunning) return;
            isRunning = true;
            currentIteration = 0;
            bestScore = 0;
            
            updateStatus('ğŸš€ å¼€å§‹ä¼˜åŒ–æç¤ºè¯...');
            
            while (isRunning && currentIteration < 20) {
                currentIteration++;
                updateProgress(currentIteration * 5);
                
                const prompt = optimizer.generatePrompt();
                updateStatus(`ğŸ“ æµ‹è¯•ç¬¬ ${currentIteration} æ¬¡è¿­ä»£...`);
                
                const result = await testPrompt(prompt);
                
                if (result.successRate > bestScore) {
                    bestScore = result.successRate;
                    bestPrompt = prompt;
                    logResult(`âœ… æ–°æœ€ä½³æˆç»©: ${(bestScore * 100).toFixed(1)}%`, 'success');
                }
                
                logResult(`è¿­ä»£ ${currentIteration}: æˆåŠŸç‡ ${(result.successRate * 100).toFixed(1)}%`);
                
                // æ˜¾ç¤ºè¯¦ç»†ç»“æœ
                for (const testResult of result.results) {
                    if (testResult.success) {
                        logResult(`  âœ“ ${testResult.sentence.substring(0, 50)}...`, 'success');
                    } else {
                        logResult(`  âœ— ${testResult.sentence.substring(0, 50)}...`, 'error');
                        if (testResult.error) {
                            logResult(`    é”™è¯¯: ${testResult.error}`, 'error');
                        }
                    }
                }
                
                // å¦‚æœè¾¾åˆ°å®Œç¾åˆ†æ•°ï¼Œåœæ­¢
                if (result.successRate >= 0.95) {
                    logResult('ğŸ‰ æ‰¾åˆ°æœ€ä¼˜æç¤ºè¯ï¼', 'success');
                    break;
                }
                
                // è¿›åŒ–æç¤ºè¯
                optimizer.evolve(result.successRate);
                
                // å»¶è¿Ÿé¿å…é¢‘ç‡é™åˆ¶
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            
            if (bestPrompt) {
                logResult('\nğŸ“‹ æœ€ä½³æç¤ºè¯:', 'warning');
                logResult(bestPrompt);
                logResult(`\næœ€ç»ˆæˆåŠŸç‡: ${(bestScore * 100).toFixed(1)}%`, 'success');
            }
            
            isRunning = false;
            updateStatus('âœ… ä¼˜åŒ–å®Œæˆ');
            updateProgress(100);
        }

        function stopOptimization() {
            isRunning = false;
            updateStatus('â¹ï¸ å·²åœæ­¢');
        }

        function clearResults() {
            document.getElementById('results').innerHTML = '';
            updateProgress(0);
        }

        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }

        function updateProgress(percent) {
            document.getElementById('progressBar').style.width = percent + '%';
        }

        function logResult(message, type = '') {
            const results = document.getElementById('results');
            const timestamp = new Date().toLocaleTimeString();
            const className = type ? ` class="${type}"` : '';
            results.innerHTML += `<div${className}>[${timestamp}] ${message}</div>`;
            results.scrollTop = results.scrollHeight;
        }
    </script>
</body>
</html>